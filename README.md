# ğŸ“š Estrutura de Dados e Algoritmos - Guia Completo

## ğŸš€ Sobre este RepositÃ³rio

Este repositÃ³rio contÃ©m uma coleÃ§Ã£o abrangente de algoritmos organizados por nÃ­veis de dificuldade e eficiÃªncia. Cada nÃ­vel inclui algoritmos fundamentais para o aprendizado e domÃ­nio de estruturas de dados, ordenaÃ§Ãµes, buscas, programaÃ§Ã£o dinÃ¢mica e otimizaÃ§Ãµes.

Seja vocÃª um iniciante em busca de aprimorar suas habilidades ou um profissional experiente em busca de referÃªncias rÃ¡pidas, este material pode ser Ãºtil para seus estudos e aplicaÃ§Ãµes.

## ğŸ“Œ Estrutura dos NÃ­veis

Os algoritmos estÃ£o organizados em cinco nÃ­veis, desde os fundamentos atÃ© tÃ©cnicas avanÃ§adas de otimizaÃ§Ã£o e computaÃ§Ã£o paralela.

---

## ğŸ“‚ NÃ­vel 1 - Algoritmos Fundamentais

ğŸ“Œ **Objetivo:** Desenvolver a lÃ³gica de programaÃ§Ã£o e entender conceitos bÃ¡sicos de estrutura de dados.

1. **Busca Linear** - Complexidade: O(n)
2. **OrdenaÃ§Ã£o por SeleÃ§Ã£o (Selection Sort)** - Complexidade: O(nÂ²)
3. **OrdenaÃ§Ã£o por Bolha (Bubble Sort)** - Complexidade: O(nÂ²)
4. **Fatorial de um NÃºmero (RecursÃ£o e IteraÃ§Ã£o)** - Complexidade: O(n)
5. **SequÃªncia de Fibonacci (Iterativo e Recursivo)** - Complexidade: O(2â¿) / O(n)
6. **MÃ©dia de um Conjunto de NÃºmeros** - Complexidade: O(n)
7. **Contagem de Elementos em uma Lista** - Complexidade: O(n)
8. **InversÃ£o de String** - Complexidade: O(n)
9. **VerificaÃ§Ã£o de NÃºmero Primo** - Complexidade: O(âˆšn)
10. **Contagem de DÃ­gitos de um NÃºmero** - Complexidade: O(log n)

---

## ğŸ“‚ NÃ­vel 2 - Algoritmos IntermediÃ¡rios

ğŸ“Œ **Objetivo:** Melhorar a eficiÃªncia e dominar buscas e ordenaÃ§Ãµes mais avanÃ§adas.

1. **Busca BinÃ¡ria** - Complexidade: O(log n)
2. **OrdenaÃ§Ã£o por InserÃ§Ã£o (Insertion Sort)** - Complexidade: O(nÂ²) / O(n)
3. **OrdenaÃ§Ã£o Merge Sort** - Complexidade: O(n log n)
4. **OrdenaÃ§Ã£o QuickSort** - Complexidade: O(n log n) / O(nÂ²)
5. **ExponenciaÃ§Ã£o RÃ¡pida** - Complexidade: O(log b)
6. **OrdenaÃ§Ã£o de Contagem (Counting Sort)** - Complexidade: O(n + k)
7. **Maior Subarray ContÃ­guo (Kadaneâ€™s Algorithm)** - Complexidade: O(n)
8. **DetecÃ§Ã£o de PalÃ­ndromo** - Complexidade: O(n)
9. **MÃ¡ximo Divisor Comum (MDC - Algoritmo de Euclides)** - Complexidade: O(log min(a, b))
10. **NÃºmero de Fibonacci - Memoization** - Complexidade: O(n)

---

## ğŸ“‚ NÃ­vel 3 - Algoritmos AvanÃ§ados

ğŸ“Œ **Objetivo:** Melhorar eficiÃªncia, lidar com estruturas de dados mais complexas e resolver problemas otimizados.

1. **OrdenaÃ§Ã£o Heap Sort** - Complexidade: O(n log n)
2. **Busca em Largura (BFS)** - Complexidade: O(V + E)
3. **Busca em Profundidade (DFS)** - Complexidade: O(V + E)
4. **Algoritmo de Dijkstra** - Complexidade: O((V + E) log V)
5. **Algoritmo de Floyd-Warshall** - Complexidade: O(VÂ³)
6. **Problema da Mochila (Knapsack Problem)** - Complexidade: O(n \* W)
7. **Algoritmo de KMP (Busca de PadrÃµes em Strings)** - Complexidade: O(n + m)
8. **Union-Find (Disjoint Set)** - Complexidade: O(Î±(n))
9. **Ãrvore de Segmentos (Segment Tree)** - Complexidade: O(log n)
10. **Algoritmo de Rabin-Karp (Busca de PadrÃµes com Hashing)** - Complexidade: O(n + m) / O(n \* m)

---

## ğŸ“‚ NÃ­vel 4 - Algoritmos AvanÃ§ados e OtimizaÃ§Ãµes

ğŸ“Œ **Objetivo:** Resolver problemas complexos com alta eficiÃªncia e dominar heurÃ­sticas e otimizaÃ§Ãµes em grafos.

1. **Algoritmo de Bellman-Ford** - Complexidade: O(V Ã— E)
2. **Algoritmo de Floyd-Warshall** - Complexidade: O(VÂ³)
3. **Algoritmo A*** (A-Star - Busca HeurÃ­stica)*\* - Complexidade: O(E) / O(VÂ²)
4. **ProgramaÃ§Ã£o DinÃ¢mica AvanÃ§ada** - Complexidade: O(n) - O(nÂ²)
5. **Algoritmo de Tarjan (SCC)** - Complexidade: O(V + E)
6. **Algoritmo de Kosaraju (SCC)** - Complexidade: O(V + E)
7. **Algoritmo de Edmonds-Karp (Fluxo MÃ¡ximo)** - Complexidade: O(V Ã— EÂ²)
8. **Algoritmo de Prim (Ãrvore Geradora MÃ­nima)** - Complexidade: O(E log V)
9. **Algoritmo de Kruskal (Ãrvore Geradora MÃ­nima)** - Complexidade: O(E log V)
10. **Fenwick Tree (Binary Indexed Tree - BIT)** - Complexidade: O(log n)

---

## ğŸ“‚ NÃ­vel 5 - Algoritmos Computacionais AvanÃ§ados e OtimizaÃ§Ã£o

ğŸ“Œ **Objetivo:** Resolver problemas de alta complexidade, computaÃ§Ã£o paralela e otimizaÃ§Ãµes NP-Hard.

1. **Algoritmo de Hopcroft-Karp (Matching em Grafos Bipartidos)** - Complexidade: O(âˆšV Ã— E)
2. **Algoritmo de Miller-Rabin (Teste de Primalidade ProbabilÃ­stico)** - Complexidade: O(k logÂ³ n)
3. **Transformada RÃ¡pida de Fourier (FFT)** - Complexidade: O(n log n)
4. **Monte Carlo e Las Vegas (Algoritmos ProbabilÃ­sticos)** - Complexidade: VariÃ¡vel
5. **Algoritmo de Branch and Bound (OtimizaÃ§Ã£o NP-Hard)** - Complexidade: Exponencial
6. **Algoritmo de Simplex (OtimizaÃ§Ã£o Linear)** - Complexidade: Exponencial no pior caso
7. **Algoritmo de Edmonds (Matching em Grafos NÃ£o Bipartidos)** - Complexidade: O(VÂ³)
8. **Ãrvores de Sufixos (Suffix Tree)** - Complexidade: O(n) / O(m)
9. **Min-Cost Max-Flow (Fluxo MÃ­nimo de Custo)** - Complexidade: O(VE log V)
10. **Algoritmo de Christofides (TSP - AproximaÃ§Ã£o)** - Complexidade: O(nÂ³)

---

## ğŸ¯ Como Utilizar

Clone o repositÃ³rio e explore os algoritmos implementados para aprendizado e prÃ¡tica.

```bash
# Clonar o repositÃ³rio
git clone https://github.com/Renatosnp1/Algoritmos.git

# Acessar o diretÃ³rio
cd Algoritmos
```

Cada algoritmo terÃ¡ sua implementaÃ§Ã£o e explicaÃ§Ã£o detalhada.

## ğŸ“¬ ContribuiÃ§Ãµes

Sinta-se Ã  vontade para contribuir com melhorias, sugestÃµes ou novas implementaÃ§Ãµes! ğŸš€

---

## ğŸ“œ LicenÃ§a

Este projeto estÃ¡ sob a licenÃ§a MIT - sinta-se livre para utilizÃ¡-lo e distribuÃ­-lo conforme necessÃ¡rio.

---

ğŸ”— **Feito com dedicaÃ§Ã£o para desenvolvedores e entusiastas da computaÃ§Ã£o.** ğŸš€

