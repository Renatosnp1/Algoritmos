# 📚 Estrutura de Dados e Algoritmos - Guia Completo

## 🚀 Sobre este Repositório

Este repositório contém uma coleção abrangente de algoritmos organizados por níveis de dificuldade e eficiência. Cada nível inclui algoritmos fundamentais para o aprendizado e domínio de estruturas de dados, ordenações, buscas, programação dinâmica e otimizações.

Seja você um iniciante em busca de aprimorar suas habilidades ou um profissional experiente em busca de referências rápidas, este material pode ser útil para seus estudos e aplicações.

## 📌 Estrutura dos Níveis

Os algoritmos estão organizados em cinco níveis, desde os fundamentos até técnicas avançadas de otimização e computação paralela.

---

## 📂 Nível 1 - Algoritmos Fundamentais

📌 **Objetivo:** Desenvolver a lógica de programação e entender conceitos básicos de estrutura de dados.

1. **Busca Linear** - Complexidade: O(n)
2. **Ordenação por Seleção (Selection Sort)** - Complexidade: O(n²)
3. **Ordenação por Bolha (Bubble Sort)** - Complexidade: O(n²)
4. **Fatorial de um Número (Recursão e Iteração)** - Complexidade: O(n)
5. **Sequência de Fibonacci (Iterativo e Recursivo)** - Complexidade: O(2ⁿ) / O(n)
6. **Média de um Conjunto de Números** - Complexidade: O(n)
7. **Contagem de Elementos em uma Lista** - Complexidade: O(n)
8. **Inversão de String** - Complexidade: O(n)
9. **Verificação de Número Primo** - Complexidade: O(√n)
10. **Contagem de Dígitos de um Número** - Complexidade: O(log n)

---

## 📂 Nível 2 - Algoritmos Intermediários

📌 **Objetivo:** Melhorar a eficiência e dominar buscas e ordenações mais avançadas.

1. **Busca Binária** - Complexidade: O(log n)
2. **Ordenação por Inserção (Insertion Sort)** - Complexidade: O(n²) / O(n)
3. **Ordenação Merge Sort** - Complexidade: O(n log n)
4. **Ordenação QuickSort** - Complexidade: O(n log n) / O(n²)
5. **Exponenciação Rápida** - Complexidade: O(log b)
6. **Ordenação de Contagem (Counting Sort)** - Complexidade: O(n + k)
7. **Maior Subarray Contíguo (Kadane’s Algorithm)** - Complexidade: O(n)
8. **Detecção de Palíndromo** - Complexidade: O(n)
9. **Máximo Divisor Comum (MDC - Algoritmo de Euclides)** - Complexidade: O(log min(a, b))
10. **Número de Fibonacci - Memoization** - Complexidade: O(n)

---

## 📂 Nível 3 - Algoritmos Avançados

📌 **Objetivo:** Melhorar eficiência, lidar com estruturas de dados mais complexas e resolver problemas otimizados.

1. **Ordenação Heap Sort** - Complexidade: O(n log n)
2. **Busca em Largura (BFS)** - Complexidade: O(V + E)
3. **Busca em Profundidade (DFS)** - Complexidade: O(V + E)
4. **Algoritmo de Dijkstra** - Complexidade: O((V + E) log V)
5. **Algoritmo de Floyd-Warshall** - Complexidade: O(V³)
6. **Problema da Mochila (Knapsack Problem)** - Complexidade: O(n \* W)
7. **Algoritmo de KMP (Busca de Padrões em Strings)** - Complexidade: O(n + m)
8. **Union-Find (Disjoint Set)** - Complexidade: O(α(n))
9. **Árvore de Segmentos (Segment Tree)** - Complexidade: O(log n)
10. **Algoritmo de Rabin-Karp (Busca de Padrões com Hashing)** - Complexidade: O(n + m) / O(n \* m)

---

## 📂 Nível 4 - Algoritmos Avançados e Otimizações

📌 **Objetivo:** Resolver problemas complexos com alta eficiência e dominar heurísticas e otimizações em grafos.

1. **Algoritmo de Bellman-Ford** - Complexidade: O(V × E)
2. **Algoritmo de Floyd-Warshall** - Complexidade: O(V³)
3. **Algoritmo A*** (A-Star - Busca Heurística)*\* - Complexidade: O(E) / O(V²)
4. **Programação Dinâmica Avançada** - Complexidade: O(n) - O(n²)
5. **Algoritmo de Tarjan (SCC)** - Complexidade: O(V + E)
6. **Algoritmo de Kosaraju (SCC)** - Complexidade: O(V + E)
7. **Algoritmo de Edmonds-Karp (Fluxo Máximo)** - Complexidade: O(V × E²)
8. **Algoritmo de Prim (Árvore Geradora Mínima)** - Complexidade: O(E log V)
9. **Algoritmo de Kruskal (Árvore Geradora Mínima)** - Complexidade: O(E log V)
10. **Fenwick Tree (Binary Indexed Tree - BIT)** - Complexidade: O(log n)

---

## 📂 Nível 5 - Algoritmos Computacionais Avançados e Otimização

📌 **Objetivo:** Resolver problemas de alta complexidade, computação paralela e otimizações NP-Hard.

1. **Algoritmo de Hopcroft-Karp (Matching em Grafos Bipartidos)** - Complexidade: O(√V × E)
2. **Algoritmo de Miller-Rabin (Teste de Primalidade Probabilístico)** - Complexidade: O(k log³ n)
3. **Transformada Rápida de Fourier (FFT)** - Complexidade: O(n log n)
4. **Monte Carlo e Las Vegas (Algoritmos Probabilísticos)** - Complexidade: Variável
5. **Algoritmo de Branch and Bound (Otimização NP-Hard)** - Complexidade: Exponencial
6. **Algoritmo de Simplex (Otimização Linear)** - Complexidade: Exponencial no pior caso
7. **Algoritmo de Edmonds (Matching em Grafos Não Bipartidos)** - Complexidade: O(V³)
8. **Árvores de Sufixos (Suffix Tree)** - Complexidade: O(n) / O(m)
9. **Min-Cost Max-Flow (Fluxo Mínimo de Custo)** - Complexidade: O(VE log V)
10. **Algoritmo de Christofides (TSP - Aproximação)** - Complexidade: O(n³)

---

## 🎯 Como Utilizar

Clone o repositório e explore os algoritmos implementados para aprendizado e prática.

```bash
# Clonar o repositório
git clone https://github.com/Renatosnp1/Algoritmos.git

# Acessar o diretório
cd Algoritmos
```

Cada algoritmo terá sua implementação e explicação detalhada.

## 📬 Contribuições

Sinta-se à vontade para contribuir com melhorias, sugestões ou novas implementações! 🚀

---

## 📜 Licença

Este projeto está sob a licença MIT - sinta-se livre para utilizá-lo e distribuí-lo conforme necessário.

---

🔗 **Feito com dedicação para desenvolvedores e entusiastas da computação.** 🚀

